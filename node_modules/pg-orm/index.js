/* S license */

/*
 @TODO
     - вывод и сохранение связей много ко многим
 */

var pg = require("pg");
var path = require('path');
var config = require('../../config');
var dbConfig = config.get("db");

function PgORM ( tableName ) {
    this.tableName = tableName;
}

PgORM.prototype.tableName;
PgORM.prototype._attributes = Object.create(null);;
PgORM.prototype.attributesRule = {};
PgORM.prototype.attributesName = {};
PgORM.prototype.attributesType = {};
PgORM.prototype.relations = {}; // BELONGS_TO, HAS_MANY
PgORM.prototype.errors = [];
PgORM.prototype.client;

// Создаем подключение к PG
var conString = "postgres://"+dbConfig.connection.user+":"+dbConfig.connection.password+"@"+dbConfig.connection.host+"/"+dbConfig.connection.database;
pg.connect(conString, function (err, client, done) {
    if(err) {
        return console .error( ' error fetching client from pool ' , err);
    }
    PgORM.prototype.client = client;
});

/**
 * Возвращает значение атрибута
 *
 * @param {attribute} название аттрибута
 * @param {callBack}.
 * @return {string} значение атрибута.
 */
PgORM.prototype.getAttribute = function (attribute, callBack){

    var thisObj = this;
    if( this.relations && this.relations[attribute] != undefined ){
        if( typeof(callBack) == 'function' ){

            if( typeof( thisObj._attributes[attribute] ) != 'object' ){
                thisObj.getRelation( attribute, function( items ){
                    thisObj.setAttribute( attribute, items );
                    callBack( items );
                })
            }
            else {
                callBack( this._attributes[attribute] );
            }
        }
    }
    else {
        if( callBack && typeof( callBack ) == "function")callBack( this._attributes[ attribute ] != undefined ? this._attributes[ attribute ] : '' );
            else return this._attributes[ attribute ] != undefined ? this._attributes[ attribute ] : '';
    }
};

PgORM.prototype.setAttribute = function (attribute, val, callBack){

    var thisObj = this;

    if( !Array.isArray( val ) ){
        this._attributes[ attribute ] = val;
        if( callBack && typeof callBack == "function")callBack( true );
                                else return this._attributes[ attribute ];
    }
        else {
        // Если подается масив, проверям является ли поле типов связь многие ком ногим
        if( val.length >0 && this.relations && this.relations[ attribute ] && this.relations[ attribute ][0] == 'HAS_MANY' ){

            var classRelation = this.relations[ attribute ][1];
            var newModel = require( "../../models/"+classRelation );
            var sql;

            val.forEach( function( value ){
                if( typeof  id == 'numeric' || typeof  id == 'string' ){
                    if( sql ) sql += ",";
                    sql += parseInt( value );
                }
            });

            if( sql ){
                newModel.fetchAll( {where:'id in ['+sql+']'}, function( items, error ){

                    if( error ){
                        callBack( false, error );
                    }
                    else {

                        thisObj._attributes[ attribute] = items;
                        if( callBack && typeof callBack == "function")callBack( true );
                    }
                });
            }
                else {
                if( callBack && typeof callBack == "function")callBack( false );
            }

        }
    }
};

PgORM.prototype.setFromObj = function( array, callBack ){

    var thisObj = this;
    if( array != undefined ){

        var queue = require("queue");
        var q = queue();

        Object.keys(array).forEach( function( field){

            q.push( function( next ){
                thisObj.setAttribute( field, array[field], function(){
                    next()
                });
            });

        });

        // Когда все задачи закончатся запустится callBack
        if( callBack && typeof callBack == 'function'){
            q.start(function(err) {
                if( err != undefined && err )callBack( errors );
                else callBack( );
            });
        }
    }
}

/**
 * Поиск записи по ID
 * @param id идетификатор записи
 * @param callback
 */

PgORM.prototype.fetch = function(id, callback){

    var thisObj = this;
    if( id != undefined && parseInt( id ) >0 ){

        this.client.query( 'SELECT * FROM '+thisObj.tableName+' WHERE id=$1::int', [ id ] , function (err, result ) {

            if(err) {
                callback( {}, 'error running query:' + err );
            }
            if( result. rows.length >0 ){
                thisObj.setFromObj( result. rows[0], function(){

                    callback( thisObj );
                });
            }
                else {
                callback();
            }
        });
    }
        else {
        callback( );
    }
}

/**
 * Поиск записи по SLUG
 * @param slug буквенный идетификатор записи
 * @param callback
 */

PgORM.prototype.fetchBySlug = function(slug, callback){

    var thisObj = this;
    if( slug && slug != undefined ){

        //callback( thisObj.client );

        this.client.query( 'SELECT * FROM '+thisObj.tableName+' WHERE slug=$1', [ slug ] , function (err, result ) {

            if(err) {
                callback( {}, 'error running query:' + err );
            }
            if( result. rows.length >0 ){
                thisObj.setFromObj( result. rows[0], function(){

                    callback( thisObj );
                });
            }
            else {
                callback();
            }
        });
    }
    else {
        callback(  );
    }
}

PgORM.prototype.clone = function clone(obj, attributesValue){
    if(obj == null || typeof(obj) != 'object')return obj;
    var temp = Object.create(obj._attributes = {});
    for(var key in obj)temp[key] = obj[key];
    temp._attributes = {};
    if( attributesValue != undefined && typeof ( attributesValue ) == 'object') {
        for (var value in attributesValue)temp.setAttribute( value, attributesValue[value] );
    }
    return temp;
}

/*
    SQLParams = {
        fields : "id, name",
        where : "id > 5",
        sort : "id DESC",
        limit : 10,
        offset : 3
    }
 */
PgORM.prototype.fetchAll = function( SQLParams, callback ){
    var table = this.tableName;
    var thisObj = this;

    if( table ){
        var sqlParams = {fields : '*', where : '', sort: 'id', limit: 10, offset : 0}
        if( typeof( SQLParams ) == 'object' ){
            if( SQLParams.fields )sqlParams.fields = SQLParams.fields;
            if( SQLParams.where )sqlParams.where = SQLParams.where;
            if( SQLParams.sort )sqlParams.sort = SQLParams.sort;
            if( SQLParams.limit )sqlParams.limit = SQLParams.limit;
            if( SQLParams.offset )sqlParams.offset = SQLParams.offset;
        }

        var sql = 'SELECT '+sqlParams.fields+' FROM '+table;
        if( sqlParams.where )sql += ' WHERE '+sqlParams.where;
        if( sqlParams.sort )sql += ' ORDER BY '+sqlParams.sort;
        if( sqlParams.limit )sql += ' LIMIT '+sqlParams.limit;
        if( sqlParams.offset )sql += ' OFFSET '+sqlParams.offset;

        this.client.query( sql , function (err, result ) {
            if(err) {
                callback( null, 'error running query( '+sql+' ):' + err );
                return false;
            }

            var resultItems = [];
            if( result.rows.length >0 ) {
                result.rows.forEach( function( item, pos ){
                    resultItems.push( thisObj.clone( thisObj, item ) );
                });
                callback( resultItems );
            }
                else callback( [] );

            return true;
        });
    }
        else callback( null );
}

PgORM.prototype.uploadFiles = function ( files, callBack, fields ){
    var queue = require("queue");
    var fs = require("fs.extra");
    var q = queue();
    var thisObj = this;

    if( typeof( files ) == 'object' ){
        var file;
        var errors = [];
        var currentDate = new Date();
        var path = 'f/'+this.tableName+'/'+currentDate.getFullYear()+'/'+( currentDate.getMonth() + 1 )+'/'+currentDate.getDate()+'/';
        if( this.getAttribute("id")>0 )path += this.getAttribute("id") + '/';

        this.getFieldsByType( this, "image").forEach( function ( field ){
            if( typeof( files[field] ) == "object" && files[field].size > 0 ){
                q.push( function(next) {
                    // Создаем категории
                    fs.mkdirRecursive('../../public/' + path, function (error) {
                        if( error )errors.push(error);
                        // Переносим файлы
                        fs.move(files[field].path, '../../public/' + path + files[field].name, function (error) {
                            // Удалем если в поле ранее был сохранен файл
                            if( thisObj.getAttribute( field ) ){
                                fs.remove( '../../public/' + thisObj.getAttribute( field ), function( error ){
                                    thisObj.setAttribute(field, path + files[field].name);
                                    next();
                                });
                            }
                            else{
                                thisObj.setAttribute(field, path + files[field].name);
                                next();
                            }
                        });
                    });
                });
            }
        });

        // Когда все задачи закончатся запустится callBack
        q.start(function(err) {
            if( err != undefined && err )callBack( null, errors );
                else thisObj.saveModel( callBack, fields );
        });
    }
    else {
        callBack( null, 'error upload' );
    }
}

PgORM.prototype.checkBeforeSave = function ( callBack, fields, files ){
    // checkbox boolean
    var thisObj = this;
    var listCheckoxField = this.getFieldsByType( this, "checkbox");
    if( typeof( listCheckoxField ) == 'object' ){
        listCheckoxField.forEach( function ( field ){
            if( thisObj.getAttribute( field ) != true )
                thisObj.setAttribute( field, false );
        });
    }

    if( typeof( files ) == 'object'){
        // Закачиваем картинки
        thisObj.uploadFiles( files, callBack, fields );
    }
        else {
        thisObj.saveModel( callBack, fields );
    }
}

/*
    files - указываем если хотим чтобы закачивались картинки
    fields - указываем если хотим чтобы сохранялись связи МНОГИЕ ко МКНОГИМ
 */

PgORM.prototype.save = function ( callback, fields, files ){

    // Обработка необходимых полей перед сохранением
    this.checkBeforeSave( callback, fields, files );
}

/**
 * Resive field's a default value
 * @param field
 */
PgORM.prototype.getFieldDefaultValue = function( field ){
  var objectTypes = this.attributesType;
  var value = "''";

  if( objectTypes[field] && objectTypes[field] == 'date' ){
    value = "null";
  }

  return value;
}

PgORM.prototype.saveModel = function ( callback, fields ){

    var queue2 = require("queue");
    var q2 = queue2();
    var attributeList = this._attributes;
    var saveList = this.attributesRule.save;
    var thisObj = this;
    var sql = "";
    var sqlFields = "";

    if( typeof( attributeList ) == 'object'){
        Object.keys( attributeList ).forEach( function ( field ){
            // проверяем чтобы сохранение было только по полям имеющим провило SAVE
            if( saveList.indexOf( field ) >-1 ){
                q2.push( function(next){
                    thisObj.getAttribute(field, function( value ){

                        if( value && !Array.isArray( value ) ){
                            if( typeof( value ) != "object" ){
                                if( sql )sql += ', ';
                                if( thisObj.getAttribute("id") > 0 )sql += field+"='" + value + "'";
                                    else sql += "'" + value + "'";
                            }

                            if( value && typeof( value ) == "object" ){
                                if( sql )sql += ', ';
                                if( thisObj.getAttribute("id") > 0 )sql += field+"='" + value.getAttribute("id") + "'";
                                    else sql += "'" + value.getAttribute("id") + "'";
                            }
                        }
                            else {
                            if( sql )sql += ', ';
                            sql += thisObj.getFieldDefaultValue( field );
                        }

                        // Для добавленя сохраняем список полей
                        if( sqlFields )sqlFields += ", ";
                        sqlFields += field;

                        next();
                    });
                });
            }
        });

        // Когда все задачи закончатся запустится callBack
        q2.start(function(err) {
            if( sql ){
                if( thisObj.getAttribute("id") > 0 )sql = 'UPDATE '+thisObj.tableName+' SET ' + sql + ' WHERE id='+thisObj.getAttribute("id")+'::int';
                else sql = 'INSERT INTO '+thisObj.tableName+'( '+sqlFields+' ) VALUES( '+sql+' )';

                if( thisObj.validate() ){

                    thisObj.sql( sql, function ( item, error ){
                        console.log('*', item);
                        if( error && error != undefined ){

                            thisObj.errors.push( error );
                            callback( null, error );
                        }
                        else {

                            if( typeof thisObj.relations == 'object' ){
                                // Сохраняем связи многие ко многим
                                thisObj.saveRelationsHasMany( fields, callback );
                            }
                            else callback( item );
                        }
                    });
                }
                else {
                    console.log( '#', sql, thisObj );
                    //thisObj.errors.push( err );
                    callback( null, thisObj.errors );
                }
            } else {
                thisObj.errors.push( "pg-rom:415 'The SQL query is wrong'" );
                callback( null, thisObj.errors );
            }

        });
    }
}

PgORM.prototype.sql = function( sql, callback ){

    var thisObj = this;
    thisObj.client.query( sql, function (err, result ) {
        if(err) {

            thisObj.errors.push( 'error running query( '+sql+' ):' + err );
            callback( null, thisObj.errors);
        }
        else {
            callback( thisObj );
        }
    });
}

PgORM.prototype.validate = function(){

    var thisObj = this;
    var errors = [];
    var fieldName = this.attributesName;

    // Проверка на REQUIRED
    this.attributesRule.required.forEach( function( field ){
        if( !thisObj.getAttribute( field ) ){
            errors.push( "Вы не заполнили обязательное поле \""+( fieldName.field ? fieldName.field :  field )+"\" " );
        }
    })

    // Проверка на INTEGER
    if( errors.length == 0 ){
        thisObj.getFieldsByType(thisObj, 'integer').forEach( function( field ){
            if( thisObj.getAttribute( field ) && typeof ( thisObj.getAttribute( field ) ) != 'number' ){
                errors.push( "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать числовое значение " );
            }
        })
    }

    // Проверка на BOOLEAN
    if( errors.length == 0 ){
        thisObj.getFieldsByType( thisObj, 'boolean').forEach( function( field ){
            if( thisObj.getAttribute( field ) && typeof( thisObj.getAttribute( field ) ) != 'boolean' ){
                errors.push( "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать Boolean значение" );
            }
        })
    }

    // Проверка EMAIL
    if( errors.length == 0 ){
        thisObj.getFieldsByType( thisObj, 'email').forEach( function( field ){
            if( thisObj.getAttribute( field ) && !thisObj.checkCorrectmail( thisObj.getAttribute( field ) ) ){
                errors.push( "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать корректный Email" );
            }
        })
    }

    // Проверка DATE
    if( errors.length == 0 ){
        thisObj.getFieldsByType( thisObj, 'date').forEach( function( field ){
            if( thisObj.getAttribute( field ) && !thisObj.checkCorrectDate( thisObj.getAttribute( field ) ) ){
                errors.push( "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать корректную дату" );
            }
        })
    }

    if( errors.length == 0 )return true;
                              else {
        thisObj.errors = errors;
        return false;
    }
}

PgORM.prototype.checkCorrectmail = function (value) {
    reg = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
    if (!value.match(reg)) return false;
                      else return true;
}

PgORM.prototype.checkCorrectDate = function (value) {

    if( typeof( value ) == "string") {
        var arrD = value.split(".");
        arrD[1] -= 1;
        var d = new Date(arrD[2], arrD[1], arrD[0]);
        if ((d.getFullYear() == arrD[2]) && (d.getMonth() == arrD[1]) && (d.getDate() == arrD[0])) {
            return true;
        }
    }

    return false;
}

PgORM.prototype.getFieldsByType = function ( thisObj, type ){
    if( thisObj.attributesType ){
        var listField = [];
        var field;
        for( var i=0;i<this.attributesRule.save.length;i++){
            field = this.attributesRule.save[i];
            if( thisObj.attributesType[field] ){
                // Если ищем поля одного типа
                if( typeof( type ) == 'string' ){
                    if( thisObj.attributesType[ field ] == type ){
                        listField.push( field );
                    }
                }
                // Если ищем поля имеющих тип из списка type
                if( typeof( type ) == 'object' ){
                    type.forEach( function( fieldType ){
                        if( thisObj.attributesType[ field ] == fieldType )listField.push( field );
                    });
                }
            }
        }
        return listField;
    }
}

PgORM.prototype.getRelation = function ( attribute, callBack ){
    var thisObj = this;
    if( this.relations && this.relations[attribute] != undefined ){
        var relation = this.relations[attribute];
        var relationObj = require( "../../models/"+relation[1] );
        if( relation[0] == 'BELONGS_TO' ){
            relationObj.fetch( thisObj._attributes[attribute], function( item, error ){
                callBack( item )
            });
        }
        if( relation[0] == 'HAS_MANY' ){
            relationObj.fetchAll({where:'id in ( SELECT right_id FROM cat_relations WHERE left_id='+thisObj.getAttribute("id")+'::int AND leftClass=\''+thisObj.tableName+'\' AND rightClass=\''+relation[1]+'\' )'}, function( items, error ){
                callBack( items )
            });
        }
    }
    else
        return [];
}

PgORM.prototype.deleteRelationsHasMany = function( relation, callBack ){
    var thisObj = this;
    if( thisObj.relations[relation] && Array.isArray( thisObj.relations[relation] ) ) {
        var sql = "DELETE FROM cat_relations WHERE ( leftClass='"+thisObj.tableName+"' AND left_id="+this.getAttribute("id")+" AND rightClass='"+thisObj.relations[relation][1]+"' ) OR (  rightClass='"+thisObj.tableName+"' AND right_id="+this.getAttribute("id")+" AND leftClass='"+thisObj.relations[relation][1]+"' )";

        thisObj.sql( sql, function( item, error ){
            if( error != 'undefined' ){

                thisObj.errors.push( error );
            }
            callBack();
        });
    }
        else
            callBack();
}

PgORM.prototype.saveRelationsHasMany = function( fields, callBack ){

    var queue = require( "queue" );
    var q = queue({concurrency:1});
    var hasRelation = false;
    var thisObj = this;

    Object.keys( this.relations ).forEach( function( relation ){
        if( thisObj.relations[relation][0] == "HAS_MANY" ){

            hasRelation = true;

            // Удаление связей перед сохранением
            q.push(
                function( next ) {
                    thisObj.deleteRelationsHasMany(relation, function () {
                        next();
                    });
                } );

            if( fields[relation]  ){

                if( !Array.isArray( fields[relation] ) )fields[relation] = [ fields[relation] ];

                q.push(
                    // Добавление связи
                    function( next ){

                        fields[relation].forEach( function( relationValue ){

                            var relationModel = Object.create( require( "../../models/cat_relations" ) );
                            relationModel.setAttribute( "leftClass", thisObj.tableName );
                            relationModel.setAttribute( "left_id", parseInt( thisObj.getAttribute("id") ) );
                            relationModel.setAttribute( "rightClass", thisObj.relations[relation][1] );
                            relationModel.setAttribute( "right_id", parseInt( relationValue ) );

                            relationModel.save( function( item, error ){
                                if( error && error != undefined ){

                                    thisObj.errors.push( error );
                                    next();
                                }
                                else {

                                    // Чтобы в базе можно не заморачиватся как искать кто слева кто справа, сохраняем запись в инверсии
                                    var relationReversModel = Object.create( require( "../../models/cat_relations" ) );
                                    relationReversModel.setAttribute( "rightClass", thisObj.tableName );
                                    relationReversModel.setAttribute( "right_id", parseInt( thisObj.getAttribute("id") ) );
                                    relationReversModel.setAttribute( "leftClass", thisObj.relations[relation][1] );
                                    relationReversModel.setAttribute( "left_id", parseInt( relationValue ) );

                                    relationReversModel.save( function( item, error2 ){
                                        if( error2 && error2 != undefined ){

                                            thisObj.errors.push( error2 );
                                        }

                                        next();
                                    });
                                }
                            });
                        });
                    }
                )
            }
        }
    });

    if( !hasRelation ){
        callBack( this );
    }
        else {

        // После завершения всех задач запускаем callBack
        q.start(  function( error ){

            if( error && error!=undefined )callBack( thisObj, thisObj.errors.toString() );
                else callBack( thisObj );
        });
    }
}

PgORM.prototype.delete = function ( callBack ){
    var thisObj = this;
    var deleteError;
    var topCallBack = callBack;
    if( thisObj.getAttribute("id") >0 ){
        // 1. Сначала удаляем все его картнки из cat_gallery,
        // 2. затем удаляем физически все картинки и файлы которые указаны в удаляемой записи
        // 3. Удалаяем все связи из таблицы cat_relations
        var Cat_gallery = require("../../models/cat_gallery");
        Cat_gallery.fetchAll( {where:'item_id='+thisObj.getAttribute('id')+'::int AND catalog=\''+thisObj.tableName+'\''}, function( items, error ){
            if( !error ){
                items.forEach( function( item ){
                    item.delete( function( error ){
                        if( error && error != undefined ){
                            deleteError = error;
                        }
                    } );
                });
            }
                else deleteError = error;

            // Удаляем связи
            var Cat_relations = require("../../models/cat_relations");
            Cat_relations.fetchAll( {where:'left_id='+thisObj.getAttribute('id')+'::int AND leftClass=\''+thisObj.tableName+'\''}, function( items, error ){
                if( !error ) {
                    items.forEach( function( item ){
                        item.delete( function( error ){
                            if( error && error != undefined ){
                                deleteError = error;
                            }
                        });
                    });
                }
                    else deleteError = error;

                if( !deleteError ) {
                    var sql = 'DELETE FROM '+thisObj.tableName+' WHERE id = '+thisObj.getAttribute('id')+'::int';
                    thisObj.client.query( sql, function (err, result) {
                        if (err) {
                            thisObj.errors[thisObj.errors.length] = 'Error running query ( '+sql+' ):' + err;
                            deleteError = error;
                            topCallBack(thisObj.errors);
                        }
                        else {

                            // Удаляем картинки и файлы если ест поля с такимм типами
                            thisObj.getFieldsByType( thisObj, ['image', 'file']).forEach( function( field ){
                                const fs = require('fs');
                                fs.unlink( "../../public/"+thisObj.getAttribute( field ), function(err){
                                    if(err)deleteError = error;
                                });
                            });
                            topCallBack();
                        }
                    });
                }
                    else topCallBack( deleteError );

            });
        });

    }
        else topCallBack( "У записи неопределен ID" );
}

PgORM.prototype.getForm = function( callBack ){
    var queue = require("queue");
    var q = queue();

    var form = '';
    var thisObj = this;
    if( this.attributesRule )
    {
        var saveFields = this.attributesRule["save"];
        var requiredFields = this.attributesRule.required;
        var attributesFields = this.attributesName;
        var placeholderFields = this.placeholder;
        var typeFields = this.attributesType;

        var required;
        var field;
        var placeholder;
        var name;
        var n;

        //If have any errors, write they
        if( this.errors.length >0 ){
            form += '<duv class="formErrors"><ul>';
            this.errors.map( function( value ){
                form += '<li>'+value+'</li>';
            })
            form += '</ul></duv>';
        }

        saveFields.forEach( function( field ){

            q.push( function( next ){
                thisObj.getInput(field, thisObj.getAttribute(field) ,typeFields, "field_" +field, field, placeholder, requiredFields,
                    function ( input ){

                        if (requiredFields && requiredFields.indexOf(field) > -1)required = true;
                        else required = false;

                        if (attributesFields && attributesFields[field])name = attributesFields[field]
                        else name = field;

                        if (placeholderFields && placeholderFields[field])placeholder = placeholderFields[field];
                        else placeholder = '';

                        form += "<div class=\"item form-group\">" +
                            "<label class=\"control-label col-md-3 col-sm-3 col-xs-12\" for=\"field_" + field + "\">" + name + " " + ( required == true ? "<span class=\"required\">*</span>" : "" ) + "</label>" +
                            "<div class=\"col-md-6 col-sm-6 col-xs-12\">" +
                            input+
                            "</div>" +
                            "</div>";

                        next();
                    });
            });
        })


        // Когда все задачи закончатся запустится callBack
        q.start(function(err) {
            if( thisObj.getAttribute("id") && thisObj.getAttribute("id") > 0 )form+='<input type="hidden" name="id" value="'+thisObj.getAttribute("id")+'" />'
            callBack( form );
        });
    }
        else callBack();
}

PgORM.prototype.getInput = function ( field, value, typeFields, id, name, placeholder, requiredFields, callBack ){
    var thisObj = this;
    var input;
    var type;
    var inputValue;
    var siteHelper = require("site-helper");
    var relations = this.relations;

    type =  ( typeFields && typeFields[field] ) ? typeFields[field] : 'varchar';
    inputValue = value && typeof ( value ) !== undefined ? value : '';

    if( relations[field] != undefined  ){
        type = "relations-"+relations[field][0];
    }

    if (requiredFields && requiredFields.indexOf(field) > -1)required = true;
    else required = false;

    // Сначала обрабатываем поля Свзяи
    if( type == "relations-BELONGS_TO" || type == "relations-HAS_MANY"  ) {
        input = "";
        this.getAttribute( field, function ( selectedItem ){
            var selectedIid;
            if( selectedItem && typeof( selectedItem ) == "object"){
                if( type == "relations-BELONGS_TO" )selectedIid = selectedItem.getAttribute("id");
                    else selectedIid = selectedItem;
            }

            var listValueModel = require("../../models/" + relations[field][1]);

            if( listValueModel != undefined && typeof( listValueModel ) == 'object' ){
                listValueModel.fetchAll({order:"name"}, function ( items ){
                    if( type == "relations-BELONGS_TO" ){
                        input += "<select name=\"" + name + "\" " + id + " class=\"select2_single form-control\"><option value=\"\"> --- --- --- </option>";

                        for( var i=0;i<items.length;i++ ){
                            var id = items[i].getAttribute("id");
                            input += "<option value=\""+id+"\" "+( selectedIid && id == selectedIid ? "selected" : "" )+" >"+items[i].getAttribute("name")+"</option>";
                        }

                        input += "</select>";
                    }
                    else {
                        input += "<div class='panel panel-default relationHasMeny'><div class='panel-body relationHasMenyBlock'>";
                        var selected = false;

                        for( var i=0;i<items.length;i++ ){
                            var id = items[i].getAttribute("id");

                            if( Array.isArray( selectedItem ) ){
                                for( var n=0;n<selectedItem.length;n++ ){

                                    if( selectedItem[n].getAttribute( "id" ) == id ) {
                                        selected = true;
                                        break;
                                    }
                                        else selected = false;
                                }
                            }

                            input += '<div class="checkbox"><label><input class="flat" '+( selected ? ' checked="checked"' : '' )+' name="' + name + '" type="checkbox" value="'+id+'" /> '+items[i].getAttribute("name")+'</label></div>';
                        }

                        input += "</div></div>";
                    }

                    callBack( input );
                });
            }
        });
    }
    // Потом обрабатываем все остальные поля
    else{
        if( type == "vtext" )
            input = "<textarea id=\"" + id + "\" class=\"mceEditor form-control col-md-7 col-xs-12\" name=\"" + name + "\" placeholder=\"" + placeholder + "\" " + ( required == true ? " required=\"required\" " : "" ) + " >"+inputValue+"</textarea>";

        if( type == "image" ){
            input = "";
            if( this.getAttribute( field ) ){
                input +='<div class="addFormImage"><img width="150" src="'+ siteHelper.getSiteUrl()+ this.getAttribute( field )+'" class="addFormInputImage" /><br/>';
                input +='<a href="#" data-file-catalog="'+this.tableName+'" data-file-item-id="'+this.getAttribute("id")+'" data-file-field="'+field+'"><i class="fa fa-close"></i> Удалить файл</a><br/></div>';
            }
            input += "<input id=\"" + id + "\" name=\"" + name + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\"file\"/>";
        }

        if( type == "checkbox" )
            input = "<input id=\"" + id + "\" class=\"flat\" value=\"1\" name=\"" + name + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\""+type+"\" "+( inputValue == 1 ? "checked" : "" )+" />";

        if( type == "url" || type == "email" )
            input = "<input id=\"" + id + "\" class=\"form-control col-md-7 col-xs-12\" name=\"" + name + "\" placeholder=\"" + placeholder + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\""+type+"\" value=\""+inputValue+"\"/>";

        if( !type || !input || type == 'varchar' )
            input = "<input id=\"" + id + "\" class=\"form-control col-md-7 col-xs-12\" name=\"" + name + "\" placeholder=\"" + ( placeholder ? placeholder : '' ) + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\"text\" value=\""+inputValue +"\"/>";

        callBack( input );
    }
}

PgORM.prototype.getInputAsync = function ( field, value, typeFields, id, name, placeholder, required ){
    var input;
    var type;
    var inputValue;
    var siteHelper = require("site-helper");

    type =  ( typeFields && typeFields[field] ) ? typeFields[field] : 'varchar';
    inputValue = typeof( value ) !== undefined ? value : '';

    if( type == "vtext" )
        input = "<textarea id=\"" + id + "\" class=\"form-control col-md-7 col-xs-12\" name=\"" + name + "\" placeholder=\"" + placeholder + "\" " + ( required == true ? " required=\"required\" " : "" ) + " >"+inputValue+"</textarea>";

    if( type == "image" ){
        input = "";
        if( this.getAttribute( field ) ){
            input +='<div class="addFormImage"><img width="150" src="'+ siteHelper.getSiteUrl()+ this.getAttribute( field )+'" class="addFormInputImage" /><br/>';
            input +='<a href="#" data-file-catalog="'+this.tableName+'" data-file-item-id="'+this.getAttribute("id")+'" data-file-field="'+field+'"><i class="fa fa-close"></i> Удалить файл</a><br/></div>';
        }
        input += "<input id=\"" + id + "\" name=\"" + name + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\"file\"/>";
    }

    if( type == "checkbox" )
        input = "<input id=\"" + id + "\" class=\"flat\" value=\"1\" name=\"" + name + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\""+type+"\" "+( inputValue == 1 ? "checked" : "" )+" />";

    if( type == "url" || type == "email" )
        input = "<input id=\"" + id + "\" class=\"form-control col-md-7 col-xs-12\" name=\"" + name + "\" placeholder=\"" + placeholder + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\""+type+"\" value=\""+inputValue+"\"/>";

    if( !type || !input || type == 'varchar' )
        input = "<input id=\"" + id + "\" class=\"form-control col-md-7 col-xs-12\" name=\"" + name + "\" placeholder=\"" + placeholder + "\" " + ( required == true ? " required=\"required\" " : "" ) + " type=\"text\" value=\""+inputValue+"\"/>";

    return input;
}

PgORM.prototype.showAttributeValue = function ( field ){
    if( this.attributesType && this.attributesType[ field ] ){
        var value;
        switch ( this.attributesType[ field ] ){
            case 'image' :
                    value = '<img src="'+this.getAttribute( field )+'" />';
                break;
            case 'checkbox' :
                    if( this.getAttribute( field ) )value = '<i class="fa fa-check"></i>';
                            else value = '';
                break;
            default : value = this.getAttribute( field );
        }

        return value;
    }
        else return this.getAttribute( field );
};

module.exports = PgORM;