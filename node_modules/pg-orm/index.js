/* S license */

/*
 @TODO
     - удаление
     -  - с удалением картинок
     - вывод формы добавления и сохранение
    - загрузку фото и файлов
    *- доделать связи много - ко многим
 */

var pg = require("pg");
var config = require('../../config');
var dbConfig = config.get("db");

function PgORM ( tableName ) {
    this.tableName = tableName;
}

PgORM.prototype.tableName;
PgORM.prototype._attributes = Object.create(null);;
PgORM.prototype.attributesRule = {};
PgORM.prototype.attributesName = {};
PgORM.prototype.attributesType = {};
PgORM.prototype.relations = {}; // BELONGS_TO, HAS_MANY
PgORM.prototype.errors = [];
PgORM.prototype.client;

// Создаем подключение к PG
var conString = "postgres://"+dbConfig.connection.user+":"+dbConfig.connection.password+"@"+dbConfig.connection.host+"/"+dbConfig.connection.database;
pg.connect(conString, function (err, client, done) {
    if(err) {
        return console .error( ' error fetching client from pool ' , err);
    }
    PgORM.prototype.client = client;
});

PgORM.prototype.getAttribute = function (attribute, callBack){

    var thisObj = this;
    if( this.relations && this.relations[attribute] != undefined ){

        if( typeof( thisObj._attributes[attribute] ) != 'object' ){
            thisObj.getRelation( attribute, function( items ){
                thisObj.setAttribute( attribute, items );
                callBack( items );
            })
        }
            else {
            callBack( this._attributes[attribute] );
        }
    }
    else return this._attributes[ attribute ];
};

PgORM.prototype.setAttribute = function (attribute, val){
    return this._attributes[ attribute ] = val;
};

/*PgORM.prototype.__noSuchProperty__ = function( id ){//, args ){
    console.log( '__noSuchProperty__' );
    console.log( id +' - '  );
}

PgORM.prototype.attributes.get = function (attr) {
    console.log( 'get 2 ' + attr  );
    return this.attributes[attr];
};

PgORM.prototype.setAttributes = function (attribute, value){
    return this.attributes[ attribute ] = value;
}*/

PgORM.prototype.setFromObj = function( array ){
    if( array != undefined ){
        for( field in array){
            this.setAttribute( field, array[field] );
        }
    }
}

PgORM.prototype.fetch = function(id, callback){
    var thisObj = this;
    if( id != undefined && id >0 ){
        this.client.query( 'SELECT * FROM catalog_users WHERE id=$1::int', [ id ] , function (err, result ) {
            if(err) {
                callback( null, 'error running query:' + err );
                return console.error( 'error running query' , err);
            }
            if( result. rows.length >0 ){
                thisObj.setFromObj( result. rows[0] );
                callback( thisObj );
            }
                else callback( );
        });
    }
}

PgORM.prototype.clone = function clone(obj, attributesValue)
{
    if(obj == null || typeof(obj) != 'object')return obj;
    var temp = Object.create(obj._attributes = {});
    for(var key in obj)temp[key] = obj[key];
    temp._attributes = {};
    if( attributesValue != undefined && typeof ( attributesValue ) == 'object') {
        for (var value in attributesValue)temp.setAttribute( value, attributesValue[value] );
    }
    return temp;
}

/*
    SQLParams = {
        fields : "id, name",
        where : "id > 5",
        sort : "id DESC",
        limit : 10,
        offset : 3
    }
 */
PgORM.prototype.fetchAll = function( SQLParams, callback ){
    var table = this.tableName;
    var thisObj = this;

    if( table ){
        var sqlParams = {fields : '*', where : '', sort: 'id', limit: 10, offset : 0}
        if( typeof( SQLParams ) == 'object' ){
            if( SQLParams.fields )sqlParams.fields = SQLParams.fields;
            if( SQLParams.where )sqlParams.where = SQLParams.where;
            if( SQLParams.sort )sqlParams.sort = SQLParams.sort;
            if( SQLParams.limit )sqlParams.limit = SQLParams.limit;
            if( SQLParams.offset )sqlParams.offset = SQLParams.offset;
        }

        var sql = 'SELECT '+sqlParams.fields+' FROM '+table;
        if( sqlParams.where )sql += ' WHERE '+sqlParams.where;
        if( sqlParams.sort )sql += ' ORDER BY '+sqlParams.sort;
        if( sqlParams.limit )sql += ' LIMIT '+sqlParams.limit;
        if( sqlParams.offset )sql += ' OFFSET '+sqlParams.offset;

        this.client.query( sql , function (err, result ) {
            if(err) {
                callback( [], 'error running query( '+sql+' ):' + err );
                return false;
            }
            if( result. rows.length >0 ){
                var resultItems = [];
                result.rows.forEach( function( item, pos ){
                    resultItems[ resultItems.length ] = thisObj.clone( thisObj, item );
                })
                callback( resultItems );
                return true;
            }
        });
    }
    callback( [] );
}

PgORM.prototype.save = function ( callback ){
    var saveList = this.attributesRule.save;
    var thisObj = this;
    var i=0;
    var sql = "";
    if( this.getAttribute("id") > 0 ){
        sql = 'UPDATE '+this.tableName+' SET ';

        saveList.forEach( function( field, num ){
            if( i >0 )sql += ', ';
            sql += field+"='" + thisObj.getAttribute(field) + "'";
            i++;
        });
        sql += " WHERE id="+this.getAttribute("id")+"::int";
    }
    else{

        var fields = "";
        var values = "";
        saveList.forEach( function( field, num ){
            if( i >0 ){
                values += ', ';
                fields += ',';
            }
            values += "'" + thisObj.getAttribute(field) + "'";
            fields += field;
            i++;
        });
        sql = 'INSERT INTO '+this.tableName+'( '+fields+' ) VALUES( '+values+' )';
    }

    if( thisObj.validate() ){
        thisObj.client.query( sql, function (err, result ) {
            if(err) {
                thisObj.errors[ thisObj.errors.length ] = 'error running query( '+sql+' ):' + err;
                callback( {}, thisObj.errors);
            }
            else {
                callback( thisObj );
            }
        });
    }
        else {
            if( typeof( thisObj.errors ) )thisObj.errors.forEach( function( error, num ){
                thisObj.errors[ thisObj.errors.length ] = error;
            });
    }

    callback( {}, thisObj.errors );
}

PgORM.prototype.validate = function(){

    var thisObj = this;
    var errors = [];
    var fieldName = this.attributesName;

    // Проверка на REQUIRED
    this.attributesRule.required.forEach( function( field ){
        if( !thisObj.getAttribute( field ) ){
            thisObj.errors[ thisObj.errors.length ] = "Вы не заполнили обязательное поле \""+( fieldName.field ? fieldName.field :  field )+"\"";
        }
    })

    // Проверка на INTEGER
    if( errors.length == 0 ){
        thisObj.getFieldsByType(thisObj, 'integer').forEach( function( field ){
            if( thisObj.getAttribute( field ) && typeof ( thisObj.getAttribute( field ) ) != 'number' ){
                thisObj.errors[ thisObj.errors.length ] = "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать числовое значение ";
            }
        })
    }

    // Проверка на BOOLEAN
    if( errors.length == 0 ){
        thisObj.getFieldsByType( thisObj, 'boolean').forEach( function( field ){
            if( thisObj.getAttribute( field ) && typeof( thisObj.getAttribute( field ) ) != 'boolean' ){
                thisObj.errors[ thisObj.errors.length ] = "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать Boolean значение";
            }
        })
    }

    // Проверка EMAIL
    if( errors.length == 0 ){
        thisObj.getFieldsByType( thisObj, 'email').forEach( function( field ){
            if( thisObj.getAttribute( field ) && !thisObj.checkCorrectmail( thisObj.getAttribute( field ) ) ){
                thisObj.errors[thisObj.errors.length] = "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать корректный Email";
            }
        })
    }

    // Проверка DATE
    if( errors.length == 0 ){
        thisObj.getFieldsByType( thisObj, 'date').forEach( function( field ){
            if( thisObj.getAttribute( field ) && !thisObj.checkCorrectDate( thisObj.getAttribute( field ) ) ){
                thisObj.errors[thisObj.errors.length] = "В поле \""+( fieldName.field ? fieldName.field :  field )+"\" необходимо указать корректную дату";
            }
        })
    }

    if( thisObj.errors.length == 0 )return true;
                              else return false;
}

PgORM.prototype.checkCorrectmail = function (value) {
    reg = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
    if (!value.match(reg)) return false;
                      else return true;
}

PgORM.prototype.checkCorrectDate = function (value) {
    console.log( value );
    if( typeof( value ) == "string") {
        var arrD = value.split(".");
        arrD[1] -= 1;
        var d = new Date(arrD[2], arrD[1], arrD[0]);
        if ((d.getFullYear() == arrD[2]) && (d.getMonth() == arrD[1]) && (d.getDate() == arrD[0])) {
            return true;
        }
    }

    return false;
}

PgORM.prototype.getFieldsByType = function ( thisObj, type ){
    if( thisObj.attributesType ){
        var listField = [];
        for( field in this._attributes ){
            if( thisObj.attributesType[field] && thisObj.attributesType[ field ] == type )listField.push( field );
        }

        return listField;
    }
}

PgORM.prototype.getRelation = function ( attribute, callBack ){
    if( this.relations && this.relations[attribute] != undefined ){
        var relation = this.relations[attribute];
        var relationObj = require( "../../models/"+relation[1] );
        relationObj.fetchAll({}, function( items ){
            callBack( items )
        });
    }
    else
        return [];
}

PgORM.prototype.delete = function ( callBack ){
    var thisObj = this;
    var deleteError;
    var topCallBack = callBack;
    if( thisObj.getAttribute("id") >0 ){
        // 1. Сначала удаляем все его картнки из cat_gallery,
        // 2. затем удаляем физически все картинки и файлы которые указаны в удаляемой записи
        // 3. Удалаяем все связи из таблицы cat_relations
        var Cat_gallery = require("../../models/cat_gallery");
        Cat_gallery.fetchAll( {where:'item_id='+thisObj.getAttribute('id')+'::int AND catalog=\''+thisObj.tableName+'\''}, function( items, error ){
            if( !error ){
                items.forEach( function( item ){
                    item.delete( function( error ){
                        if( error != undefined ){
                            deleteError = error;
                        }
                    } );
                });
            }
                else deleteError = error;

            // Удаляем связи
            var Cat_relations = require("../../models/cat_relations");
            Cat_relations.fetchAll( {where:'left_id='+thisObj.getAttribute('id')+'::int AND leftClass=\''+thisObj.tableName+'\''}, function( items, error ){
                if( !error ) {
                    items.forEach( function( item ){
                        item.delete( function( error ){
                            if( error != undefined ){
                                deleteError = error;
                            }
                        });
                    });
                }
                    else deleteError = error;

                if( !deleteError ) {
                    var sql = 'DELETE FROM '+thisObj.tableName+' WHERE id = '+thisObj.getAttribute('id')+'::int';
                    thisObj.client.query( sql, function (err, result) {
                        if (err) {
                            thisObj.errors[thisObj.errors.length] = 'Error running query ( '+sql+' ):' + err;
                            deleteError = error;
                            topCallBack(thisObj.errors);
                        }
                        else {

                            // Удаляем картинки и файлы если ест поля с такимм типами
                            thisObj.getFieldsByType( thisObj, 'image').forEach( function( field ){
                                const fs = require('fs');
                                fs.unlink( "../../public/"+thisObj.getAttribute( field ), function(err){
                                    if(err)deleteError = error;
                                });
                            });
                            topCallBack();
                        }
                    });
                }
                    else topCallBack( deleteError );

            });
        });

    }
        else topCallBack( "У записи неопределен ID" );
}
module.exports = PgORM;